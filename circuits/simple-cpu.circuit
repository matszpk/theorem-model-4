# Simple 4-bit CPU
# cell_len_bits: 4, address_len: 8
# Registers:
#  A - accumlator (4-bit)
#  S - stack pointer (4-bit)
#  F - flags (3 - N, 1 - Z 0 - C)
#  PC - program counter (8-bit)
# Instruction set:
# 0 - LDA - load into accumulator
# 1 - STA - store accumulator
# 2 - ADC - add to accumulator (A + M + C)
# 3 - SBC - subtract from accumulator (A - NOT(M) +C)
# 4 - AND - perform bitwise AND on accumulator
# 5 - OR - perform bitwise OR on accumulator
# 6 - XOR - perform bitwise XOR on accumulator
# 7 - CLC
# 8 - ROL - rotate left 1 bit including C.
# 9 - ROR - rotate right 1 bit including C.
# A - BCC - branch if C=0
# B - BNE - branch if Z=0
# C - BPL - branch if N=0
# D - JMP
# E - PSH - push
# F - PUL - pull, if SP=0 then STOP
main:
    # input (state):
    alias cpu_state_0 i0
    alias cpu_state_1 i1
    alias cpu_state_2 i2
    alias cpu_instr_0 i3
    alias cpu_instr_1 i4
    alias cpu_instr_2 i5
    alias cpu_instr_3 i6
    # program counter
    alias cpu_pc_0 i7
    alias cpu_pc_1 i8
    alias cpu_pc_2 i9
    alias cpu_pc_3 i10
    alias cpu_pc_4 i11
    alias cpu_pc_5 i12
    alias cpu_pc_6 i13
    alias cpu_pc_7 i14
    alias cpu_acc_0 i15
    alias cpu_acc_1 i16
    alias cpu_acc_2 i17
    alias cpu_acc_3 i18
    alias cpu_flag_c i19
    alias cpu_flag_z i20
    alias cpu_flag_n i21
    # stack pointer
    alias cpu_sp_0 i22
    alias cpu_sp_1 i23
    alias cpu_sp_2 i24
    alias cpu_sp_3 i25
    alias cpu_tempreg_0 i26
    alias cpu_tempreg_1 i27
    alias cpu_tempreg_2 i28
    alias cpu_tempreg_3 i29
    alias mem_value_0 i30
    alias mem_value_1 i31
    alias mem_value_2 i32
    alias mem_value_3 i33
    
    one = nand zero zero
    
    # cpu_state_state_0_n = nand cpu_state_state_0 cpu_state_state_0
    # cpu_state_state_1_n = nand cpu_state_state_1 cpu_state_state_1
    # cpu_state_state_2_n = nand cpu_state_state_2 cpu_state_state_2
    
    ########
    # phase 0 - fetch instruction
    
    # 1 if cpu_state_0 == 0
    # ch_phase_0 = and_3 cpu_state_state_0_n cpu_state_state_1_n cpu_state_state_2_n
    
    alias mem_address_0_ph012 cpu_pc_0
    alias mem_address_1_ph012 cpu_pc_1
    alias mem_address_2_ph012 cpu_pc_2
    alias mem_address_3_ph012 cpu_pc_3
    alias mem_address_4_ph012 cpu_pc_4
    alias mem_address_5_ph012 cpu_pc_5
    alias mem_address_6_ph012 cpu_pc_6
    alias mem_address_7_ph012 cpu_pc_7
    
    alias mem_rw_ph012 zero
    
    cpu_pc_0_ph0 cpu_pc_1_ph0 cpu_pc_2_ph0 cpu_pc_3_ph0 \
        cpu_pc_4_ph0 cpu_pc_5_ph0 cpu_pc_6_ph0 cpu_pc_7_ph0 = \
        inc_8bit cpu_pc_0 cpu_pc_1 cpu_pc_2 cpu_pc_3 cpu_pc_4 cpu_pc_5 cpu_pc_6 cpu_pc_7
    
    # next cpu state
    alias cpu_state_0_ph0 one
    alias cpu_state_1_ph0 zero
    alias cpu_state_1_ph01 zero
    
    ########
    # phase 1 - fetch address nibble 0 only if not CLC, PSH, PUL, ROL, ROR
    # if CLC, ROL, ROR then go to phase 3.
    # if PSH, PUL then go to phase 2.
    
    # move mem_value into cpu_instr_0_ph1
    alias cpu_instr_0_ph1 mem_value_0
    alias cpu_instr_1_ph1 mem_value_1
    alias cpu_instr_2_ph1 mem_value_2
    alias cpu_instr_3_ph1 mem_value_3
    
    alias mem_address_0_ph1 cpu_pc_0
    alias mem_address_1_ph1 cpu_pc_1
    alias mem_address_2_ph1 cpu_pc_2
    alias mem_address_3_ph1 cpu_pc_3
    alias mem_address_4_ph1 cpu_pc_4
    alias mem_address_5_ph1 cpu_pc_5
    alias mem_address_6_ph1 cpu_pc_6
    alias mem_address_7_ph1 cpu_pc_7
    
    alias mem_rw_ph0 zero
    
    # clc_rol_ror_psh_pull
    tmp0 = nand cpu_instr_2_ph1 cpu_instr_3_ph1
    tmp1 = nand cpu_instr_2_ph1 cpu_instr_0_ph1
    tmp2 = nand cpu_instr_1_ph1 cpu_instr_1_ph1
    tmp3 = nand cpu_instr_3_ph1 tmp0
    tmp4 = nand tmp0 tmp1
    tmp5 = nand tmp2 cpu_instr_1_ph1
    tmp6 = nand tmp4 cpu_instr_0_ph1
    tmp7 = nand tmp6 tmp2
    
    # next cpu state
    if_clc_rol_ror = nand tmp5 tmp7
    alias cpu_state_0_ph1 if_clc_rol_ror
    alias cpu_state_1_ph1 one
    
    # increment if not CLC, ROL or ROR.
    cpu_pc_0_ph1 cpu_pc_1_ph1 cpu_pc_2_ph1 cpu_pc_3_ph1 = ite_4bit if_clc_rol_ror \
        cpu_pc_0 cpu_pc_1 cpu_pc_2 cpu_pc_3 \
        cpu_pc_0_ph0 cpu_pc_1_ph0 cpu_pc_2_ph0 cpu_pc_3_ph0
    cpu_pc_4_ph1 cpu_pc_5_ph1 cpu_pc_6_ph1 cpu_pc_7_ph1 = ite_4bit if_clc_rol_ror \
        cpu_pc_4 cpu_pc_5 cpu_pc_6 cpu_pc_7 \
        cpu_pc_4_ph0 cpu_pc_5_ph0 cpu_pc_6_ph0 cpu_pc_7_ph0
    
    # merge phase0 and phase1
    # mem_address and mem_rw are same
    cpu_pc_0_ph012 cpu_pc_1_ph012 cpu_pc_2_ph012 cpu_pc_3_ph012 = ite_4bit cpu_state_0 \
        cpu_pc_0_ph1 cpu_pc_1_ph1 cpu_pc_2_ph1 cpu_pc_3_ph1 \
        cpu_pc_0_ph0 cpu_pc_1_ph0 cpu_pc_2_ph0 cpu_pc_3_ph0
    cpu_pc_4_ph012 cpu_pc_5_ph012 cpu_pc_6_ph012 cpu_pc_7_ph012 = ite_4bit cpu_state_0 \
        cpu_pc_4_ph1 cpu_pc_5_ph1 cpu_pc_6_ph1 cpu_pc_7_ph1 \
        cpu_pc_4_ph0 cpu_pc_5_ph0 cpu_pc_6_ph0 cpu_pc_7_ph0
    cpu_state_0_ph01 = ite cpu_state_0 cpu_state_0_ph1 cpu_state_0_ph0
    cpu_state_1_ph01 = ite cpu_state_0 cpu_state_1_ph1 cpu_state_1_ph0
    cpu_instr_0_ph01 cpu_instr_1_ph01 cpu_instr_2_ph01 cpu_instr_3_ph01 = ite_4bit \
        cpu_state_0 cpu_instr_0_ph1 cpu_instr_1_ph1 cpu_instr_2_ph1 cpu_instr_3_ph1 \
        cpu_instr_0 cpu_instr_1 cpu_instr_2 cpu_instr_3
    
    zero = copy zero
    
    ########
    # phase 2 - fetch address nibble 1 
    # only if not CLC, PSH, PUL, ROL, ROR.
    
    # move mem_value into cpu_tempreg_0 - first nibble of address argument
    alias cpu_tempreg_0_ph2 mem_value_0
    alias cpu_tempreg_1_ph2 mem_value_1
    alias cpu_tempreg_2_ph2 mem_value_2
    alias cpu_tempreg_3_ph2 mem_value_3
    
    # this same operation like in phase 1 - increment PC.
    alias cpu_pc_0_ph2 cpu_pc_0_ph1
    alias cpu_pc_1_ph2 cpu_pc_1_ph1
    alias cpu_pc_2_ph2 cpu_pc_2_ph1
    alias cpu_pc_3_ph2 cpu_pc_3_ph1
    alias cpu_pc_4_ph2 cpu_pc_4_ph1
    alias cpu_pc_5_ph2 cpu_pc_5_ph1
    alias cpu_pc_6_ph2 cpu_pc_6_ph1
    alias cpu_pc_7_ph2 cpu_pc_7_ph1
    
    alias cpu_state_0_ph2 one
    alias cpu_state_1_ph2 one
    
    # merge phase0, phase1 and phase2
    cpu_state_0_n = nand cpu_state_0 cpu_state_0
    cpu_state_1_n = nand cpu_state_1 cpu_state_1
    if_phase_2 = and_3 cpu_state_0_n cpu_state_1_n cpu_state_2
    
    cpu_tempreg_0_ph012 cpu_tempreg_1_ph012 cpu_tempreg_2_ph012 cpu_tempreg_3_ph012 = ite_4bit \
        if_phase_2 cpu_tempreg_0_ph2 cpu_tempreg_1_ph2 cpu_tempreg_2_ph2 cpu_tempreg_3_ph2 \
        cpu_tempreg_0 cpu_tempreg_1 cpu_tempreg_2 cpu_tempreg_3
    cpu_state_0_ph01 = ite if_phase_2 cpu_state_0_ph2 cpu_state_0_ph01
    cpu_state_0_ph01 = ite if_phase_2 cpu_state_1_ph2 cpu_state_1_ph01
    cpu_instr_0_ph012 cpu_instr_1_ph012 cpu_instr_2_ph012 cpu_instr_3_ph012 = ite_4bit \
        if_phase_2 cpu_instr_0 cpu_instr_1 cpu_instr_2 cpu_instr_3 \
        cpu_instr_0_ph01 cpu_instr_1_ph01 cpu_instr_2_ph01 cpu_instr_3_ph01
    
    ########
    # phase 3 - if not JMP then load/store to memory
    # only if not CLC, PSH, PUL, ROL, ROR.
    # if JMP, BCC, BNE or BPL then store address to PC and finish instruction.
    # if STA - then store accumulator to memory and finish instruction.
    # if PSH then store accumulator to stack and increment SP and finish instruction.
    # if PUL then prepare mem_address for stack and decrement SP and go to phase 3.
    # otherwise - then load from memory (set mem_address).
    
    tmp0 = nand cpu_instr_1 cpu_instr_3
    tmp1 = nand cpu_instr_3 cpu_instr_2
    tmp2 = nand tmp0 tmp1
    tmp3 = nand tmp2 tmp1
    tmp4 = nand tmp0 tmp2
    if_jump = nand tmp4 tmp5
    
    cpu_pc_0_ph3 cpu_pc_1_ph3 cpu_pc_2_ph3 cpu_pc_3_ph3 = ite_4bit if_jump \
        cpu_tempreg_0 cpu_tempreg_1 cpu_tempreg_2 cpu_tempreg_3 \
        cpu_pc_0 cpu_pc_1 cpu_pc_2 cpu_pc_3
    cpu_pc_4_ph3 cpu_pc_5_ph3 cpu_pc_6_ph3 cpu_pc_7_ph3 = ite_4bit if_jump \
        mem_value_0 mem_value_1 mem_value_2 mem_value_3 \
        cpu_pc_4 cpu_pc_5 cpu_pc_6 cpu_pc_7
    
    tmp0 = nand cpu_instr_1 cpu_instr_1
    tmp1 = nand cpu_instr_3 cpu_instr_2
    tmp2 = nand cpu_instr_0 cpu_instr_2
    tmp3 = nand cpu_instr_3 tmp0
    tmp4 = nand tmp0 cpu_instr_0
    tmp5 = nand tmp4 tmp1
    tmp6 = nand tmp5 tmp2
    tmp7 = nand tmp3 tmp6
    tmp8 = nand tmp7 tmp3
    if_sta_psh = nand tmp8 tmp8
    
    alias mem_rw_ph3 if_sta_psh
    alias mem_value_0_ph3 cpu_acc_0
    alias mem_value_1_ph3 cpu_acc_1
    alias mem_value_2_ph3 cpu_acc_2
    alias mem_value_3_ph3 cpu_acc_3
    
    cpu_instr_0_n = nand cpu_instr_0 cpu_instr_0
    if_psh = and_4 cpu_instr_0_n cpu_instr_1 cpu_instr_2 cpu_instr_3
    if_pul = and_4 cpu_instr_0 cpu_instr_1 cpu_instr_2 cpu_instr_3
    cpu_sp_0_inc cpu_sp_1_inc cpu_sp_2_inc cpu_sp_3_inc ign = carry_inc_4bit \
        zero cpu_sp_0 cpu_sp_1 cpu_sp_2 cpu_sp_3
    cpu_sp_0_dec cpu_sp_1_dec cpu_sp_2_dec cpu_sp_3_dec = dec_4bit \
        cpu_sp_0 cpu_sp_1 cpu_sp_2 cpu_sp_3
    cpu_sp_0_tmp cpu_sp_1_tmp cpu_sp_2_tmp cpu_sp_3_tmp = ite_4bit if_psh \
        cpu_sp_0_inc cpu_sp_1_inc cpu_sp_2_inc cpu_sp_3_inc \
        cpu_sp_0 cpu_sp_1 cpu_sp_2 cpu_sp_3
    # cpu_sp_0_ph3 cpu_sp_1_ph3 cpu_sp_2_ph3 cpu_sp_3_ph3 = ite_4bit if_pul \
        cpu_sp_0_dec cpu_sp_1_dec cpu_sp_2_dec cpu_sp_3_dec \
        cpu_sp_0_tmp cpu_sp_1_tmp cpu_sp_2_tmp cpu_sp_3_tmp
        
    # merge phase0, phase1, phase2 and phase3
    
    ########
    # phase 4 - get memory value (if needed) and execute operation.
    
    # merge phase0, phase1, phase2, phase3, phase4
    
    o0 = copy cpu_state_0
    o1 = copy cpu_state_1
    o2 = copy cpu_state_2
    o3 = copy cpu_instr_0
    o4 = copy cpu_instr_1
    o5 = copy cpu_instr_2
    o6 = copy cpu_instr_3
    o7 = copy cpu_pc_0
    o8 = copy cpu_pc_1
    o9 = copy cpu_pc_2
    o10 = copy cpu_pc_3
    o11 = copy cpu_pc_4
    o12 = copy cpu_pc_5
    o13 = copy cpu_pc_6
    o14 = copy cpu_pc_7
    o15 = copy cpu_acc_0
    o16 = copy cpu_acc_1
    o17 = copy cpu_acc_2
    o18 = copy cpu_acc_3
    o19 = copy cpu_flag_c
    o20 = copy cpu_flag_z
    o21 = copy cpu_flag_n
    o22 = copy cpu_sp_0
    o23 = copy cpu_sp_1
    o24 = copy cpu_sp_2
    o25 = copy cpu_sp_3
    o26 = copy cpu_tempreg_0
    o27 = copy cpu_tempreg_1
    o28 = copy cpu_tempreg_2
    o29 = copy cpu_tempreg_3
    o30 = copy mem_value_0
    o31 = copy mem_value_1
    o32 = copy mem_value_2
    o33 = copy mem_value_3
    # mem_rw
    o34 = copy zero
    # mem_address
    o35 = copy zero
    o36 = copy zero
    o37 = copy zero
    o38 = copy zero
    o39 = copy zero
    o40 = copy zero
    o41 = copy zero
    o42 = copy zero
    # create
    o43 = copy zero
    # stop
    o44 = copy zero
copy:
    t = nand i0 i0
    o0 = nand t t
xor:
    n0 = nand i0 i0
    n1 = nand i1 i1
    t0 = nand i0 n1
    t1 = nand n0 i1
    o0 = nand t0 t1
and_3:
    t0 = nand i0 i1
    t0 = nand t0 t0
    t1 = nand i2 t0
    o0 = nand t1 t1
and_4:
    t0 = nand i0 i1
    t0 = nand t0 t0
    t1 = nand i2 i3
    t1 = nand t1 t1
    t2 = nand t0 t1
    o0 = nand t2 t2
# if i0 then i1 else i2
ite:
    n0 = nand i0 i0
    t0 = nand i0 i1
    t1 = nand n0 i2
    o0 = nand t0 t1
xor_4bit:
    o0 = xor i0 i4
    o1 = xor i1 i5
    o2 = xor i2 i6
    o3 = xor i3 i7
ite_4bit:
    o0 = ite i0 i1 i5
    o1 = ite i0 i2 i6
    o2 = ite i0 i3 i7
    o3 = ite i0 i4 i8
copy_4bit:
    o0 = copy i0
    o1 = copy i1
    o2 = copy i2
    o3 = copy i3
not_4bit:
    o0 = nand i0 i0
    o1 = nand i1 i1
    o2 = nand i2 i2
    o3 = nand i3 i3
full_adder:
    t0 = nand i1 i2
    t1 = nand t0 i1
    t2 = nand i2 t0
    t3 = nand t2 t1
    t4 = nand t3 i0
    t5 = nand i0 t4
    t6 = nand t4 t3
    o0 = nand t5 t6
    o1 = nand t0 t4
half_adder:
    t0 = nand i0 i1
    t2 = nand i0 t0
    t3 = nand t0 i1
    o0 = nand t2 t3
    o1 = nand t0 t0
half_suber:
    t0 = nand i1 i1
    t1 = nand i0 i0
    t1 = nand t0 t1
    t0 = nand i1 i0
    t2 = nand t1 t1
    o0 = nand t0 t1
    o1 = nand t2 t2
# i0 - carry, i1-i4 - 4-bit A, i5-i8 - 4-bit B
carry_adder_4bit:
    s0 c0 = full_adder i1 i5 i0
    s1 c1 = full_adder i2 i6 c0
    s2 c2 = full_adder i3 i7 c1
    s3 c3 = full_adder i4 i8 c2
    o0 o1 o2 o3 = copy_4bit s0 s1 s2 s3
    o4 = copy c3
# 4-bit subtractor with carry
# i0 - carry, i1-i4 - 4-bit A, i5-i8 - 4-bit B
carry_suber_4bit:
    n0 n1 n2 n3 = not_4bit i5 i6 i7 i8
    s0 c0 = full_adder i1 n0 i0
    s1 c1 = full_adder i2 n1 c0
    s2 c2 = full_adder i3 n2 c1
    s3 c3 = full_adder i4 n3 c2
    o0 o1 o2 o3 = copy_4bit s0 s1 s2 s3
    o4 = copy c3
carry_inc_4bit:
    s0 c0 = half_adder i1 i0
    s1 c1 = half_adder i2 c0
    s2 c2 = half_adder i3 c1
    s3 c3 = half_adder i4 c2
    o0 o1 o2 o3 = copy_4bit s0 s1 s2 s3
    o4 = copy c3
dec_4bit:
    d0 c0 = half_suber i0 zero
    d1 c1 = half_suber i1 c0
    d2 c2 = half_suber i2 c1
    d3 c3 = half_suber i3 c2
    o0 o1 o2 o3 = copy_4bit d0 d1 d2 d3
inc_8bit:
    one = nand zero zero
    s0 s1 s2 s3 c0 = carry_inc_4bit one i0 i1 i2 i3
    s4 s5 s6 s7 ign = carry_inc_4bit c0 i4 i5 i6 i7
    o0 o1 o2 o3 = copy_4bit s0 s1 s2 s3
    o4 o5 o6 o7 = copy_4bit s4 s5 s6 s7
